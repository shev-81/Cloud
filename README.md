<h1 align="center">Cloud
<h3 align="center">Облачное хранилище файлов (Java IO, NIO, Netty, StreamAPI + Java FX)</h3>

<a href="https://shev-81.github.io/Cloud-netty/"><img src="https://img.shields.io/badge/Cloud-JavaDoc-green"/>  </a>


## 0. Предисловие 
Проект написан, в рамках изучения мной сетевого фреймворка `Netty`, я решил создать облачную систему хранения файлов с `Netty` в качестве ядра. Мной рассматривалось два варианта реализации прикладного протокола взаимодействия между сервером и клиентом. Первый вариант, это работа с передаваемыми байтами через `ByteBuffer Netty`, и второй это работать с настроенными `PipeLine фильтром` (который, к слову все так же работает с `ByteBuffer`, ведь все, что летит по сети - это Байты! ), в котором использовать фильтры сериализации исходящих сообщений и десериализации входящих. Я выбрал второй вариант - работать с объектами, хотя протокол написанный мной в рамках другого проекта с байтами показал большую эффективность.

> <b>Netty</b> — это инфраструктура клиент/сервер, которая использует расширенные сетевые возможности Java, скрывая за собой сложность и предоставляя простой в использовании API.

> <b>В рамках проекта реализованно:</b>

- <b>Сервер Netty</b> запускается и подключает клиентов, пересылает служебные сообщения от клиентов (котороые так же могут нести в себе данные из файла), отвечает за авторизацию пользователей, использует `Data Base SQLite`, для хранения данных пользователей (работа с Data Base через `JDBC`), распределяет и контроллирует выделяемое под пользователей дисковое пространство, по запросу от клиентов проводит действия на закрепленном  за пользователем дисковом пространстве. 
- <b>Клиент Java FX</b> запускаясь предлагает пользователю авторизоваться и при успехе предоставляет доступ к основному графическому интерфейсу `(GUI)`. `GUI` показывает состояние хранилища для пользователя: наличие файлов и их свойства, общую наполненность до `10 Gb` (это размер дискогвого пространства, выделяемого каждому пользователю на сервере). Так же `GUI` содержит элементы управления позволяющие выполнять следующие действия.
   - Принять и записать файлы пользователя.
   - Передать файлы пользователю. 
   - Удалить файлы с дискового пространства пользователя. 

> <b>Техническая часть</b>
 - `IDE: IntelliJ IDEA 2021.3.3`
 - `Версия JDK: 1.8.0_121 + 16 на стороне клиента.`
 - `Netty Framework`
 - `SQLite`
> <b>Используемые технологии:</b>
 - `Java FX`
 - `Java IO, NIO`
 - `Stream API`
 - `Netty`
 - `CSS`
 - `JDBC`
 - `Мавен 3.5`
 
 > <b>Вид программы в Production.</b>
  
  ![2022-08-26_21-40-44](https://user-images.githubusercontent.com/89448563/186971668-ee48358c-436e-4c15-8dde-a004855b0fbc.png)

Передача данных между клиентом и сервером основанна на Object Message, сообщения могут содержать данные из передаваемых файлов и не превышают 
лимит в 10 Mb. При передаче файлов больших размеров файл разрезается на куски и по частям пересылается.  

## 1. Модуль Server

### 1.1 API ядра Netty

Когда запускается сервер Netty, в нем настраивается конвеер `Pipe Line` для обработки получаемых из сети данных. Все данные получаемые приложением из сети попадают в `Byte Bufer` сервера `Netty`  и проходят через `Pipe Line` до `Main Handler'a`. Для обработки полученных байтов из `Byte Buffer'a` используются сериализатор и десериализатор. Полученные таким образом объекты приходят в конечную точку `Pipe Line` в `MainHandler`. Если необходимо отправить сообщение в сеть, происходит обратный процесс пошаговой обработки в `Pipe Line`. Сдесь нужно сказать, что элементы `PipeLine` могут обрабатывать как входящий поток так и исходящий или быть как `MainHandler` конечной точкой.

![api-netty](https://user-images.githubusercontent.com/89448563/187065711-7b930405-2e5f-456a-a80f-f6c2d6009df9.png)

- <b>`Object Decoder`</b> - Декодер, десериализует полученный байтовый буфер в объекты Java.
- <b>`Object Encoder`</b> - Кодировщик, который сериализует объект Java в байтбуфер.
- <b>`MainHandler`</b> - является точкой соприкосновения cо всеми сервисами программы.

### 1.2 MainHandler

Нужно упоминуть, что для каждого подключаемого клиента создается свой PipeLine содержащий все элементы, и так же MainHandler. Создавая новый `PipeLine`, MainHandler получает ссылку на сервис авторизации и запускает регистратор слушателей служебных сообщений `RegistryHandler` прописывающий в себе ссылки на методы обработки входящих сообщений по их типу (патерн Registry). При получении из `PipeLine` входящего объекта сообщения в `MainHandler` вызывается `RegistryHandler` и из него достается зарегистрированный под этот тип сообщения слушатель - свой `Handler` и выполняется метод для обработки пришедшего сообщения. 
   
> Регистрация слушателей.
   
    ...
    private Map<Class<? extends AbstractMessage>, RequestHandler> mapHandlers;
    ...   
    public RegistryHandler(Controller controller) {
        this.mapHandlers = new HashMap<>();
        mapHandlers.put(AuthMessage.class, new AuthHandler(controller)::authHandle);
        mapHandlers.put(RegUserRequest.class, new RegUserHandler(controller)::regHandle);
        mapHandlers.put(FileMessage.class, new FileHandler(controller)::fileHandle);
        mapHandlers.put(FilesSizeRequest.class, new FilesSizeRequestHandler(controller)::filesSizeReqHandle);
    }

Где `RequestHandler` является функциональным интерфейсом
   
    @FunctionalInterface
    public interface RequestHandler {
       void handle(ChannelHandlerContext ctx, Object msg);
    }

   
> <b>Схема обработки входящих сообщений в `MainHandler` </b>

![MainHandler](https://user-images.githubusercontent.com/89448563/187069114-ff894097-34f2-4c83-9bc1-a90873432183.png)
   
> Используются следующие зарегистрированные слушатели:

- <b>`AuthHandler`</b> - Используя сервис авторизации пользователей, выполняет авторизацию пользователя на сервере. (для хранения данных пользователей используется локальная SQLite база данных). При успешной авторизации на сервере предоставляет доступ к рабочему функционалу облака.
- <b>`DelFileHandler`</b> - Удаляет файл из облака пользователя.
- <b>`FileHandler`</b> - Получает сообщение с данными файла и записывает на диск. 
- <b>`FilesListRequestHandler`</b> - Отвечает на запрос о состояние Облака, для пользователя, отправившего запрос.
- <b>`FileHandler`</b> - Обрабатывает запрос на регистрацию нового пользователя, проверяет, есть ли в базе данных пользователь с таким же ником, если есть, то отправляет отказ в регистрации, а при отсутствии регистрирует его и отправляет ответ клиенту, что регистрация прошла успешно.
- <b>`ReqFileHandler`</b> - Обрабатывает запрос от клиента на получение файла, если файл весит более 10 Мб,  разрезает его на части по 10 Мб. и отправляет клиенту.

> Получение `MainHandler'om` объекта сообщения из конвеера `Netty` и обработка с помощью `HandlerRegistry` - <b>паттерн Registry</b>.

    public void channelRead(ChannelHandlerContext ctx, Object msg){
        RequestHandler handler = registryHandler.getHandler(msg.getClass());
        handler.handle(ctx, msg);
    }

Сила функциональных интерфейсов в том, что если метод по сигнатуре параметров совпадает с методом фунциоанального интерфейса, то можно сохранить ссылку на этот метод обработчика из registryHandler в переменной `handler` интерфейса RequestHandler. И в завершении  вызвать метод интерфейса `handle(ctx, msg)` передав ему одинаковые параметры для выполнения метода из `registryHandler`.


## 2. Модуль клиент

На стороне клиента архитектура сетевого взаимодействия такая же, как и на сервере: с разницей в реализуемом клиенте `Netty`. В клиенте так же настраивается `PipeLine` с декодером, энкодером и `MainHandler'om`, в котором зарегистрированные слушатели получают объекты сообщений. 

### 2.1 <b>Панели авторизации и регистрации.</b>

При старте приложения запускается форма ввода логина и пароля.

![2022-08-30_20-09-53](https://user-images.githubusercontent.com/89448563/187499373-18b22a60-389b-467b-9f1d-adadf8559c41.png)

Если аккаунта нет, можно перейти по ссылке "Don't hаve an accaunt?" и произойдет смена панелей. Панель ввода логина и пароля станет неактивной и вместо нее активный фокус заберет панель регистрации нового пользователя.

![2022-08-30_20-12-24](https://user-images.githubusercontent.com/89448563/187499824-9963c981-f2ba-4162-b7c3-4053ee92a936.png)

Обе формы принимающие пользовательский ввод, проверяют корректность заполнения предлагаемых полей. К примеру если в форме авторизации не ввести логин или пароль, то соединение для передачи информации не будет открыто! Потому что, обработчик выдаст ошибку и подсветит текстовую метку красным цветом, картинка ниже.

![2022-08-30_20-14-33](https://user-images.githubusercontent.com/89448563/187500651-356f85cd-0b56-43b7-83b1-9ffa6574b18d.png)

Если все впорядке и данные введены, будет созданно сетевое подключение и сообщение авторизации `AuthMessage` c логином и паролем будет отправлено на сервер. Пользователь пройдет процесс аутентификации, при котором клиент и сервер несколько раз обменяются служебными сообщениями. Клиент будет проверен по его логину и паролю в Базе данных и при успешной проверке Сервис `AuthService` вернет Имя `NickName` пользователя и сервер вернет клиенту сообщение `AuthMessage`. Получение такого сообщения с Именем клиента и списком фалов в облаке расценивается, как успешная авторизация клиента и ему будет предоставлена панель управления облаком сервера.

> Клиент предоставляет следующий функционал управления:

- <b>`Add`</b> - добавление файлов из ОС пользователя в Облако.
- <b>`Delete`</b> - удаление выбранного файла с Облака.
- <b>`Get`</b> - копирование файлов с Облака клиенту.


![2022-08-30_20-32-15](https://user-images.githubusercontent.com/89448563/187504992-832c95f7-fcaa-4c0f-bb9d-bee72c5f115c.png)

В открывшееся окно с сервера подгрузится актуальная информация: список файлов этого клиента и общая загруженность облака (лимит до 10 Gb).

Спасибо! если дочитали до конца.


